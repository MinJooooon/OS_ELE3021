# Process / Thread
+ Process
  + Simply, a process is a computer program running on a computer
  + Each process has its own independent resources, such as address spaces(code, data, heap, stack) and file descriptors

+ Context switching between processes
  1. Save some information(address space) of current process onto its kernel stack
  2. Restore a few for the soon-to-be-executing process from its kernel stack
  3. Switch to the kernel stack for the soon-to-be-executing process

+ Thread
  + Thread is an executing flow inside a single process
  + Multiple threads can exist inside a single process
  + What threads existing in the same process share
    + Address space except stack(which means code, data, heap)
  + What threads existing in the same process don't share
    + its own stack
    + PC register

+ Context switching between threads
  + Relatively faster than context switching between processes because shared resources(code, data, heap, etc) don't have to be switched

# POSIX thread
+ `int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg)`
  + Starts a new thread in the calling process
  + `pthread_t *thread`: Id of thread made by this function
  + `const pthread_attr_t *attr`: Indicates various information(e.g. stack size) of thread generated by this function
  + `void *(*start_routine)(void *)`: Thread executes user code from this address
  + `void *arg`: Argument of `start_routine`
  + When the thread is successfully created, it returns 0
  + When it fails, it returns non-zero such as EAGAIN, EFAULT, EINVAL

+ `int pthread_join(pthread_t thread, void **ret_val)`
  + Waits for the thread specified by `thread` to terminate.
  + `pthread_t thread`: Id of a target thread
  + `void **ret_val`: A pointer to the value passed by pthread_exit or return of the terminated thread
  + When it successes, it returns 0
  + When it fails, it returns non-zero such as EDEADLK, EFAULT, EINVAL

+ `void pthread_exit(void *ret_val)`
  + Terminates the calling thread
  + `void *ret_val`: Will be passed to the thread which joins this thread.

# Design Basic LWP Operations for xv6
+ Understanding
  + Project goal
    + improving the multitasking capabilities of xv6 by implementing an abstraction of LWP

  + LWP
    + Light Weight Process
    + A process that shares resources such as address space with other processes in the same LWP group
    + LWPs in the same LWP group also share page table
      + Therefore, newly created LWP doesn't have to allocate new page table and can just use the existing process's page table
    + LWPs has its own stack even if they are in the same LWP group
      + Therefore, newly created LWP has to allocate its own stack, and of course it has its own `esp`
  + Context switching
    + The procedure of context switching between LWPs within the same group should be implemented differently from that of a normal process
    + When a context switching occurs between LWPs within the same group, an LWP should switch its context with another LWP directly: which means, context switching between an LWP and the scheduler never occurs
    + Context switching within the LWP group occurs every 1 tick in a given time quantum
  + MLFQ
    + All LWPs within the same LWP group should share their time quantum, and time allotment
  + Stride
    + All LWPs within the same LWP group should share their time quantum
    + When an LWP calls set_cpu_share(), all LWPs in that group have to be managed by the stride scheduler

+ A rough design
  + `struct proc`
    + `int lwpid`
      + Id of LWP
      + 0 for normal process
    + `int lwp_master_pid`
      + Pid of master of LWP group
      + 0 for normal processes and master of LWP group
    + `void* retval`
      + Return value of LWP when executes `thread_exit`
  + `int thread_create(thread_t *thread, void *(*start_routine)(void*), void *arg)`
    + When a normal process calls this function, it creates a new process by using fork(), and the calling process becomes a master of LWP group
    + A forked process becomes a member of the LWP group
    + Copy the page table of master process and then share it with members of the LWP group
    + Allocates stack for forked process by using allocuvm()
    + Sets `esp` of `trapframe` of forked process to point the address of allocated stack
    + Sets `eip` of `trapframe` of forked process to point the address of start_routine
    + `lwpid` starts with 1 and increases if additional LWP is created
    + Within the same LWP group, `lwp_master_pid` is `pid` of master of LWP group
    + If done successfully, return 0
 
  + `int thread_join(thread_t thread, void **retval)`
    + Find an LWP with an `lwpid` that matches the given argument `thread` by looping over `ptable`
    + If there is no such LWP, return immediately
    + If found LWP's state is `ZOMBIE`, clean up page table, allocated memories and stacks of the LWP
    + If done successfully, return 0

  + `void thread_exit(void *retval)`
    + Store return value in calling LWP's `retval`
    + Change the calling LWP's state to `ZOMBIE`

  + Interaction with system calls in xv6
    + Basic Operations
      + LWPs should share their address space within the same LWP group, while having their own context and stack
    + `exit`
      + Find all LWPs which has the same `lwp_master_pid` with the calling process by looping over `ptable`
      + Clean up them by using the method similar to `thread_join`
      + Normal process is terminated in the same way as the `exit` system call does
    + `fork`
      + Fork the new process in the same way as the `fork` system call does
      + The address space of the LWP must be copied from the calling process normally
    + `exec`
      + Find all LWPs which has the same `lwp_master_pid` with the calling process by looping over `ptable`
      + Clean up them by using the method similar to `thread_join`
      + Master LWP of the LWP group does `exec` normally
    + `sbrk`
      + Each LWPs in the same LWP group shares the same address space
      + When multiple LWPs simultaneously call `sbrk`, the race condition would be happen if I don't take care of concurrency
      + Locking of `ptable` is properly needed to prevent race condition between LWPs
      + The expanded memory area must be shared among LWPs
    + `kill`
      + If more than one LWP is killed, all LWPs in the LWP group must be terminated and the resources for each LWPs in that process must be cleaned
    + `pipe` and `sleep`
      + Implemented just as an original xv6 does

  + Interaction with MLFQ scheduler
    + All LWPs within the same LWP group should share their time quantum and time allotment
    + Each LWP group should have their `spent_tick` and `spent_allotment` variable for sharing among LWPs
    + Each level of the queue adopts RR policy with different time quantum
      + The highest priority queue: 5 ticks
      + Middle priority queue: 10 ticks
      + The lowest priority queue: 20 ticks
    + Each queue has different time allotment
      + The highest priority queue: 20 ticks
      + Middle priority queue: 40 ticks
    + To prevent starvation, priority boosting is needed for every 200 ticks

  + Interaction with Stride scheduler
    + The default time quantum is 5 ticks
    + When an LWP calls set_cpu_share(), all LWPs in that group have to be managed by the stride scheduler
    + The total sum of CPU shares requested from processes in the stride queue cannot exceed 80% of the CPU time

  + Important thing about scheduling
    + When a context switching occurs between LWPs within the same group, an LWP should switch its context with another LWP directly; context switching between an LWP and the scheduler never occurs